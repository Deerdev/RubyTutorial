#!/usr/bin/ruby -w
# -*- coding : utf-8 -*-
# -----------------------------------------------

# 0. intro

# 方法名应以小写字母开头。
# 如果您以大写字母作为方法名的开头，Ruby 可能会把它当作常量，从而导致不正确地解析调用。
# 方法应在调用之前定义，否则 Ruby 会产生未定义的方法调用异常。

# 定义一个简单的方法，如下所示：
def method_name 
   expr..
end

# 您可以定义一个接受参数的方法，如下所示：
def method_name (var1, var2)
   expr..
end

# 您可以为参数设置默认值，如果方法调用时未传递必需的参数则使用默认值：
def method_name (var1=value1, var2=value2)
   expr..
end

# 当您要调用方法时，只需要使用方法名即可，如下所示：
method_name

# 但是，当您调用带参数的方法时，您在写方法名时还要带上参数，例如：
method_name 25, 30


def test(a1="Ruby", a2="Perl")
   puts "编程语言为 #{a1}"
   puts "编程语言为 #{a2}"
end
test "C", "C++"
test


# -----------------------------------------------

# 1. 方法返回值
# Ruby 中的每个方法默认都会返回一个值。这个返回的值是最后一个语句的值。例如：

def test
   i = 100
   j = 10
   k = 0
end

# 在调用这个方法时，将返回最后一个声明的变量 k。

# 使用return，可以返回一个值 或 多个值
# return 1, 2


# -----------------------------------------------

# 2. 可变数量的参数

# 假设您声明了一个带有两个参数的方法，当您调用该方法时，您同时还需要传递两个参数。

# 但是，Ruby 允许您声明参数数量可变的方法。让我们看看下面的实例：
 
def sample (*test)
   puts "参数个数为 #{test.length}"
   for i in 0...test.length
      puts "参数值为 #{test[i]}"
   end
end
sample "Zara", "6", "F"
sample "Mac", "36", "M", "MCA"


# -----------------------------------------------


# 3. 类方法

# 当方法定义在[类的外部]，方法默认标记为 private。
# 另一方面，如果方法定义在[类中]的，则默认标记为 public。
# 方法默认的可见性和 private 标记可通过模块（Module）的 public 或 private 改变。
# 当你想要访问类的方法时，您首先需要实例化类。然后，使用对象，您可以访问类的任何成员。

# Ruby 提供了一种不用实例化即可访问方法的方式：

class Accounts
   def reading_charge
   end
   # 类方法
   def Accounts.return_date
   end
end

# return_date 声明: 通过在类名后跟着一个点号，点号后跟着方法名来声明的。您可以直接访问类方法，如下所示：

# 如需访问该方法，您不需要创建类 Accounts 的对象:
Accounts.return_date


# -----------------------------------------------


# 4. alias 语句

# 这个语句用于为方法或全局变量起别名。别名不能在方法主体内定义。
# 即使方法被重写，方法的别名也保持方法的当前定义。

# 为编号的全局变量（$1, $2,...）起别名是被禁止的。重写内置的全局变量可能会导致严重的问题。

# alias 方法名 方法名
# alias 全局变量 全局变量


alias foo bar
alias $MATCH $&

# 为 bar 定义了别名为 foo，为 $& 定义了别名为 $MATCH。


# -----------------------------------------------


# 5. undef 语句
# 这个语句用于取消方法定义。undef 不能出现在方法主体内。

# 通过使用 undef 和 alias，类的接口可以从父类独立修改，但请注意，在自身内部方法调用时，它可能会破坏程序。

# undef 方法名


# 下面的实例取消名为 bar的方法定义：
undef bar

